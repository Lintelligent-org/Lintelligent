using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Lintelligent.Core.Abstractions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Lintelligent.Core.Analyzers
{
    public class ComplexConditionalAnalyzer : IAnalyzerRule
    {
        private const int MaxNestingDepth = 3;
        public string Id => "LNT003";
        public string Description => "Conditional statements should not be nested more than 3 levels deep";
        public Severity Severity => Severity.Warning;
        public string Category => DiagnosticCategories.CodeSmell;

        public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
        {
            if (IsGeneratedCode(tree))
                yield break;

            var root = tree.GetRoot();

            // Check both if statements and switch statements
            var ifStatements = root.DescendantNodes().OfType<IfStatementSyntax>();
            var switchStatements = root.DescendantNodes().OfType<SwitchStatementSyntax>();

            var allConditionals = ifStatements
                .Concat(switchStatements.Cast<SyntaxNode>());

            foreach (var conditional in allConditionals)
            {
                // Start at 1 to count the current node itself
                var depth1 = 1;
                var current = conditional.Parent;

                while (current != null)
                {
                    if (current is IfStatementSyntax || current is SwitchStatementSyntax)
                    {
                        // Check if this is an else-if chain (not true nesting)
                        // An else-if is when an IfStatement is the only statement in an ElseClause
                        if (current is IfStatementSyntax {Parent: ElseClauseSyntax elseClause} ifStmt &&
                            elseClause.Statement == ifStmt)
                        {
                            // This is an else-if, skip counting it as nesting
                            // But continue checking its parents
                        }
                        else
                            depth1++;
                    }

                    current = current.Parent;
                }

                var depth = depth1;

                if (depth <= MaxNestingDepth) continue;
                var line = conditional.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
                var message = $"Conditional nesting depth is {depth} (max: {MaxNestingDepth}). " +
                              "Consider extracting nested logic into separate methods or using guard clauses.";

                yield return new DiagnosticResult(
                    tree.FilePath,
                    Id,
                    message,
                    line,
                    Severity,
                    Category
                );
            }
        }

        private static bool IsGeneratedCode(SyntaxTree tree)
        {
            var fileName = Path.GetFileName(tree.FilePath);
            if (fileName.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase) ||
                fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
                fileName.Contains(".Generated.")) return true;
            SyntaxNode root = tree.GetRoot();
            IEnumerable<SyntaxTrivia> leadingTrivia = root.GetLeadingTrivia().Take(10);
            return leadingTrivia.Any(t =>
                t.ToString().Contains("<auto-generated>") ||
                t.ToString().Contains("<auto-generated />"));

        }
    }
}
